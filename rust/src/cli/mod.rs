use std::path::PathBuf;

use crate::errors::CommandLineArgsError;
use crate::obfuscation::Pin;
use clap::{Args, Parser, Subcommand};

/// Converts a string into a valid `PathBuf`, ensuring it exists on disk.
fn rationalise_file_path(path: &str) -> Result<PathBuf, CommandLineArgsError> {
    let path_buf = PathBuf::from(path);
    // If the path doesn't exist, return an error
    if path_buf.exists() {
        Ok(path_buf)
    } else {
        Err(CommandLineArgsError::FilePathIsNotValid)
    }
}

/// Converts a string pin into a `Pin` struct, ensuring it has no zeros
/// and can be parsed as a nonzero u32.
fn rationalise_pin(pin: &str) -> Result<Pin, CommandLineArgsError> {
    // Check for invalid '0' in the pin and return an error if found
    if pin.contains('0') {
        return Err(CommandLineArgsError::PinShouldNotContainZero);
    }

    // Attempt to parse the string to a u32, mapping any parsing errors appropriately
    let num: u32 = pin
        .parse()
        .map_err(CommandLineArgsError::PinIsNotAValidNumber)?;

    // Convert number to a vector of its digits
    let digits: Vec<u16> = num
        .to_string()
        .chars()
        .map(|c| c.to_digit(10).unwrap() as u16) // Safe unwrap because we know it's all digits
        .collect();

    // Return a Pin struct containing the digits
    Ok(Pin(digits))
}

// Parser structure for CLI, defined using clap attributes for auto parsing
#[derive(Parser)]
#[clap(
    author,
    version,
    about = "A command line seed mixer",
    long_about = "Provides a terminal based method for secure distribution of seed phrases."
)]
pub struct Cli {
    // Define the CLI subcommands
    #[command(subcommand)]
    pub command: Command,
}

// CLI arguments structure for mix command
#[derive(Args)]
pub struct MixArgs {
    #[clap(short, long)]
    pub lang: String,

    #[clap(short, long)]
    // The pin for obfuscation, with detailed help on constraints and usage
    #[arg(short, long, value_parser = rationalise_pin, help = "Supply the pin for obfuscation. Each digit in the pin can be between 1 and 9 exclusive. The total length of the pin should be less than or equal to the length of the seed. The number of digit in a pin should also be a factor of the length of the seed.  I.e. for a 24 word seed, the applicable pin lengths are 4,6,8,12,24. Please see documentation for more details")]
    pub pin: Pin,

    #[clap(short, long)]
    pub shares: usize,

    #[clap(short, long)]
    pub threshold: usize,

    #[arg(short, long, value_parser = rationalise_file_path, help = "Optionally supply a file that contains the seed words on separate lines")]
    pub file_path: Option<PathBuf>,

    #[arg(short, long, help = "Optionally encrypt shares")]
    pub encrypt: bool,

    #[arg(
        long,
        help = "Optionally encrypt shares with key from seed phrase rather than generated key"
    )]
    pub encryption_phrase: Option<String>,

    #[arg(short, long, help = "Override file name prefix")]
    pub override_file_name: Option<String>,
}

// CLI arguments structure for mix command
#[derive(Args)]
pub struct UnMixArgs {
    #[arg(short, long,required=true, value_parser = rationalise_file_path, help = "Optionally supply a file that contains the seed words on separate lines")]
    pub file_path: Vec<PathBuf>,

    #[clap(short, long)]
    pub lang: String,

    // The pin for obfuscation, with detailed help on constraints and usage
    #[clap(short, long)]
    #[arg(short, long, value_parser = rationalise_pin, help = "Supply the pin for obfuscation. Each digit in the pin can be between 1 and 9 exclusive. The total length of the pin should be less than or equal to the length of the seed. The number of digit in a pin should also be a factor of the length of the seed.  I.e. for a 24 word seed, the applicable pin lengths are 4,6,8,12,24. Please see documentation for more details")]
    pub pin: Pin,

    #[arg(
        short,
        long,
        conflicts_with = "decryption_phrase",
        help = "The secret key that was generated by mixer when the original mixing was done"
    )]
    pub decryption_key: Option<String>,

    #[arg(
        long,
        conflicts_with = "decryption_key",
        help = "The secret phrase that used by mixer when the original mixing was done"
    )]
    pub decryption_phrase: Option<String>,

    #[arg(
        short,
        long,
        help = "Output the recovered seed to a terminal rather than a file"
    )]
    pub terminal: bool,

    #[arg(short, long, help = "Override file name prefix")]
    pub override_file_name: Option<String>,
}

// CLI arguments structure for mix command
#[derive(Args)]
pub struct ShredArgs {
    #[arg(short, long,required=true, value_parser = rationalise_file_path, help = "Supply file paths to be shredded")]
    pub file_path: Vec<PathBuf>,
}
// CLI arguments structure for checking a word list
#[derive(Args)]
pub struct CheckWordListArgs {
    #[clap(short, long)]
    pub lang: String,
    #[clap(short, long)]
    pub position: String,
}

#[derive(Args)]
pub struct CheckWordIndexArgs {
    #[clap(short, long)]
    pub lang: String,
    #[clap(short, long)]
    pub word: String,
}

// Enum to represent different commands that can be executed via CLI
#[derive(Subcommand)]
pub enum Command {
    #[command()]
    Shred(ShredArgs),
    #[command()]
    Mix(MixArgs),
    #[command()]
    Unmix(UnMixArgs),
    #[command(aliases = ["chk"])]
    CheckWordList(CheckWordListArgs),
    #[command(aliases = ["chi"])]
    CheckWordIndex(CheckWordIndexArgs),
}

#[cfg(test)]
mod tests {
    use proptest::{prop_assert, prop_assert_eq};

    use {
        super::*,
        proptest::{
            prelude::{ProptestConfig, Strategy},
            proptest,
        },
        test_case::test_case,
    };

    // Strategy to generate non-zero u32 strings that are valid pin inputs
    fn non_zero_u32_string_strategy() -> impl Strategy<Value = String> {
        (1_000u32..=u32::MAX) // Ensuring at least 4 digits, up to the max u32 value
            .prop_map(|n| n.to_string()) // Convert the number to a string
            .prop_filter("Must be 4 to 12 digits long without zeros", |s| {
                s.len() <= 12 && !s.contains('0')
            })
    }

    // Strategy to generate u32 strings that contain zeros
    fn zero_u32_string_strategy() -> impl Strategy<Value = String> {
        (1_000u32..=u32::MAX) // Ensuring at least 4 digits, up to the max u32 value
            .prop_map(|n| n.to_string())
            .prop_filter("Must be 4 to 12 digits long with zeros", |s| {
                s.len() <= 12 && s.contains('0')
            })
    }

    // Test case to verify rationalise_pin function with specific inputs
    #[test_case("1234", vec![1,2,3,4]; "When expected vector is specified")]
    fn test_rationalise_pin(pin: &str, expected: Vec<u16>) {
        let c = rationalise_pin(pin);
        assert!(
            c.is_ok(),
            "Expected the pin to be able to be split correctly."
        );
        assert!(
            c.unwrap().0 == expected,
            "Expected the pin to be equal to the expected pin vector."
        );
    }

    // Property-based tests to ensure rationalise_pin works as expected across a range of valid pins
    proptest! {
        #![proptest_config(ProptestConfig::with_cases(1000))]
        #[test]
        fn test_rationalise_pin_prop(pin in non_zero_u32_string_strategy()) {
        println!("{}",pin);
        let c = rationalise_pin(&pin)?;

         let joined = c.0.iter().map(|&s| s.to_string()).collect::<Vec<_>>().join("");
            prop_assert_eq!(&pin, &joined, "Expected the deconstruction of the pin to be equal to the concatenation of the characters: {}", pin);
        }

        // Test to verify the function correctly errors on pins containing zero
        #[test]
        fn test_rationalise_pin_should_fail_if_it_contains_zero_prop(pin in zero_u32_string_strategy()) {
        println!("{}",&pin);
        let c = rationalise_pin(&pin);
        prop_assert!(
            c.is_err(),
            "Expected the pin to error if it contains zero."
        );
        }
    }
}
